<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    
    
    

    <title>「开源软件」类别的文章 - 欧雷流</title>
    <description>助力「反混沌」落地，减少「混乱」与「杂音」的存在；让每个人在网上做「自己」，尽可能「独立」且「自由」。</description>
    <link>https://ourai.ws/categories/open-source/</link>
    <atom:link href="https://ourai.ws/categories/open-source/rss.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 11 Mar 2025 01:01:01 +0800</pubDate>
    <lastBuildDate>Tue, 11 Mar 2025 01:01:01 +0800</lastBuildDate>
    <language>zh-CN</language>
    <generator>Jekyll v3.0.3</generator>
    
      <item>
        <title>说说「反混沌」：Future.js</title>
        
          <dc:creator>欧雷</dc:creator>
          <author>欧雷</author>
        
        <description>&lt;p&gt;相信看到「Future.js」这个名字，会想起前些日子某厂连续开源的好几个前端相关项目之一的「Modern.js」——没错！就像「&lt;a href=&quot;/posts/fxxk-design-from-anti-chaos/&quot;&gt;Fxxk Design&lt;/a&gt;」一样，这个名字也是受「启发」而起的，也是把一些正在建设中与规划要做的项目进行了「概念包装」。&lt;/p&gt;

&lt;p&gt;从目前的了解来看，Modern.js 是要建设「大而全」的体系和打造「事实标准」。这种目标我是支持的，但反对由商业组织牵头，尤其是国内的，应该由非盈利个人/组织发起并牵头主导与社区共建——不会出现 KPI 开源等情况。&lt;/p&gt;

&lt;p&gt;「大而全」的体系和打造「事实标准」是相辅相成的，一个「大而全」的体系和一系列「事实标准」可以让当前混乱的 Web 前端变得更加有序，让技术深耕技术，令业务专注业务——这也是「&lt;a href=&quot;/posts/hello-world-from-anti-chaos/&quot;&gt;反混沌&lt;/a&gt;」要做的事情。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;业界现状&lt;/h2&gt;

&lt;p&gt;在 React/Vue、Babel/Webpack 等出现并流行之前的 jQuery 时代，前端开发是「面向页面」的，并且几乎没有构建工具的参与，这时的范式可以说是「手动」或「人工」——DOM 的操作和数据的更新都要写很多代码去处理。&lt;/p&gt;

&lt;p&gt;当 React/Vue、Babel/Webpack 等流行起来后，前端开发转为「基于组件」的，不仅代码的内聚性大幅提升，DOM 操作也不用费心了——React/Vue 这一类库/框架将视图结构的变化与状态进行了绑定，状态变化时视图结构就会跟着变化。&lt;/p&gt;

&lt;p&gt;与此同时，掀起了「工程化」潮流，构建工具链越发成熟，谱写了「流程自动化」的序章——可以认为当代的范式是「半自动」。&lt;/p&gt;

&lt;p&gt;伴随着 Node.js 的问世与发展，前端不断地扩展着自己的能力边界——从 GUI 到 CLI，从运行时到编译时，从前端到后端，甚至是跳到 Rust、Dart 等非 JS 系的语言去了……&lt;/p&gt;

&lt;p&gt;然而，这些层出不穷的技术对于业务开发人员来说无疑是不友善的——&lt;/p&gt;

&lt;p&gt;最直接的影响就是分散注意力。业务开发人员的主要关注点应该是业务相关的事情，如领域知识、业务需求的落地等，而不是三天两头的「新技术」轰炸。搞得人人都很焦虑，恨不得多买点课程抓紧时间学，连吃饭拉屎都在学！&lt;/p&gt;

&lt;p&gt;然后就是提高了业务开发的复杂度。回想一下当初新立个项目都需要做啥，与现在对比下，哪个让页面跑起来更容易更简单些？哪个出现问题了排查起来更好找些？说实话，我听到 Babel/Webpack 就青筋抽动。&lt;/p&gt;

&lt;p&gt;上面所列的是当前很明显很有影响的两个问题，为前端开发带来了混乱——这是（我认为的）下一代范式要着重解决的，同时也是「反混沌」的使命——促进前端工业化进程，打造装配导向的工业流水线。&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;{{ &#39;posts/20211105/paradigm-shift&#39; | asset_path }}&quot; alt=&quot;仿 Modern.js 的「范式转移」&quot; /&gt;
  &lt;figcaption&gt;仿 Modern.js 的「范式转移」&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;最近这几年也有其他人/团队在向类似方向探索，例如飞冰。但它们的一些关键特性不是我想要的——锁定在某个视图库/框架上，并且是背靠商业组织。&lt;/p&gt;

&lt;h2 id=&quot;futurejs&quot;&gt;Future.js&lt;/h2&gt;

&lt;p&gt;要治理这混乱局势，有两个关键点——将系统（广义的）各个层次、各个环节之间的通信规范化、标准化，这就需要一个「大而全」的体系和一系列「事实标准」；足够的抽象和封装，让上层业务开发人员无需太去关注具体用的是什么技术以及怎么去用，并帮他们更好更快地完成业务需求。&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;{{ &#39;posts/20211105/layers&#39; | asset_path }}&quot; alt=&quot;解决方案分层&quot; /&gt;
  &lt;figcaption&gt;解决方案分层&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;也许有人会说：「都规范化、标准化了，你让那些做业务开发的还怎么跳槽？！」我只想说：「真想提高自己的话，快速把业务需求完成之后用那省下来的时间去参与标准和基础设施的建设不好吗？」&lt;/p&gt;

&lt;p&gt;作为「反混沌」体系的子体系之一，「Future.js」就是「大而全」的体系和「事实标准」在工具层面的体现。&lt;/p&gt;

&lt;p&gt;名字中「Future」的含义不是它代表自己是「未来的做法」、「未来的方向」，而是「Future-oriented」，即「面向未来」。因此，它不是一个「大而全」的「框架」，而是「大而全」的、可自由组合、渐进式的「生态矩阵」。&lt;/p&gt;

&lt;p&gt;「Future.js」的目标不仅是让前端开发变得有序，更是要做好前端的「本职工作」——连接（产品、UX/UI）设计与后端。在这一点上，「Future.js」的方向是「配置驱动」。&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;{{ &#39;posts/20211105/trinity&#39; | asset_path }}&quot; alt=&quot;仿 Modern.js 的「三位一体」&quot; /&gt;
  &lt;figcaption&gt;仿 Modern.js 的「三位一体」&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;总的来说，「Future.js」表面上是一套 JS-based 的解决方案，在有些场景会借助于其他语言的能力。与「Fxxk Design」一样，该体系下的项目将采用分层、低耦合的架构作为基本原则。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;建设中的&lt;/h3&gt;

&lt;p&gt;最先要解决的就是配置化开发中后台前端应用，目前与「Fxxk Design」体系相结合的部分架构为——&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;{{ &#39;posts/20211105/futurejs-and-fxxk-design&#39; | asset_path }}&quot; alt=&quot;「Future.js」与「Fxxk Design」结合&quot; /&gt;
  &lt;figcaption&gt;「Future.js」与「Fxxk Design」结合&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;图中所示架构的思想在「&lt;a href=&quot;/series/talking-about-frontend-of-web-based-management-systems/&quot;&gt;聊聊中后台前端应用&lt;/a&gt;」系列文章中已经说明，这里不再赘述。可以看出，整体分为底层的 Organik 和上层的 Handie 这两大部分。&lt;/p&gt;

&lt;p&gt;Organik 是一个配置驱动，或者说元数据驱动的逻辑引擎，主要作用就是收集各类元数据，如数据类型描述、模型描述、UI 组件描述、渲染类型描述、视图描述、模块描述等，根据需要将它们进行关联生成各种上下文。&lt;/p&gt;

&lt;p&gt;Handie 则是一个包装在 Organik 和 Petals 外面的「壳儿」，直接面向业务开发人员。其内部又分为三层——技术栈无关的 &lt;code&gt;handie&lt;/code&gt;；连接技术栈的 &lt;code&gt;handie-vue&lt;/code&gt; 与 &lt;code&gt;handie-react&lt;/code&gt; 等；将上下文与 UI 组件连接的 &lt;code&gt;@handie/bulbasaur&lt;/code&gt;（Vue）和 &lt;code&gt;@handie/squirtle&lt;/code&gt;（React）之类。&lt;/p&gt;

&lt;p&gt;Handie 的定位是「渐进式元数据驱动中后台前端应用开发解决方案」，所以说，它支持在已有中后台前端应用的基础上逐步改造为完全的配置化开发。&lt;/p&gt;

&lt;p&gt;在上文中提到，React/Vue 通过将视图结构的变化与状态绑定，做到了视图结构的响应式更新，让上层开发人员将关注点聚焦于状态的维护。&lt;/p&gt;

&lt;p&gt;Handie 要做到更进一步的简化——用更简单的方式从对状态的维护变为对业务规则的维护，将关注点更加聚焦于业务本身。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;规划中的&lt;/h3&gt;

&lt;p&gt;前端的疆土很广阔，「Future.js」所处的领域只是其中的一部分。虽然已经做了有段时间了，但将视野拉到更远处，只能说现在仍处于「刚起步」的阶段，还有很多事情需要做。&lt;/p&gt;

&lt;p&gt;当前的 Organik 和 Handie 再加上「Fxxk Design」中的 Petals 与 Kokiri，只做了一些三层架构中的逻辑层和表现层的事情，数据层可以说还一点没做。因此，在它们比较完善了之后首当其冲去做些数据层的工作。&lt;/p&gt;

&lt;p&gt;在现在，光有运行时的引擎不能说自己是一个「框架」，配套设施得跟得上啊！所以 CLI 工具、脚手架、IDE 插件、装饰器等都要安排上！&lt;/p&gt;

&lt;p&gt;再稍微往远点看，基于 Web Components 的解决方案、可视化编辑等等都要做。&lt;/p&gt;

&lt;p&gt;看到这，肯定会觉得：「咦？等等！这不就是飞冰嘛！」&lt;/p&gt;

&lt;p&gt;哎……这就是「范式转移」带来的一个问题——范式是变了，但需求并没有变，因此要在新的范式指导下把旧的范式下做过的东西再做一遍——就像一个业务系统用新语言或新技术重写一样。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;上面列举的并不是全部，拍脑袋想想，「Future.js」的边界大概就是低代码/无代码工具/平台了吧！具体包含哪些，要做什么，想象空间很大！但，这些都是表象——「Future.js」的本质是「大而全」的体系和「事实标准」。&lt;/p&gt;

&lt;p&gt;那些被「新技术」轰炸焦虑得人都要变「蕉绿」的，整天喊「学不动」了的，想要提升又不在大厂或平台类部门苦于没有机会的，还不参与到「Future.js」中来？！&lt;/p&gt;

&lt;p&gt;治理混乱，反混沌，不是我一个人的事儿，是大家的事儿。&lt;/p&gt;

&lt;p&gt;我愿充当先行者！&lt;/p&gt;
</description>
        <pubDate>Fri, 05 Nov 2021 14:14:22 +0800</pubDate>
        <link>https://ourai.ws/posts/futurejs-from-anti-chaos/</link>
        <guid isPermaLink="true">https://ourai.ws/posts/futurejs-from-anti-chaos/</guid>
        
        <category>open-source</category>
        
        
        <category>frontend-web-development</category>
        
        <category>frontend-engineering</category>
        
        <category>open-source-software</category>
        
        <category>anti-chaos</category>
        
        <category>futurejs</category>
        
      </item>
    
      <item>
        <title>说说「反混沌」：Fxxk Design</title>
        
          <dc:creator>欧雷</dc:creator>
          <author>欧雷</author>
        
        <description>&lt;p&gt;就在前几天，集结很多业内大牛的某厂连续开源了好几个前端相关项目，其中两个是 UI 组件库。嗬家伙！同时来俩，到底是想让人用哪个啊？存心想要逼死纠结星人的节奏？&lt;/p&gt;

&lt;p&gt;这俩 UI 组件库的名字里都有「Design」，表明自己是「Design System」而不是普通的「UI Library」。这让我想起了这段时间一波又一波出现的「元宇宙」公司。嗯～熟悉的味道。&lt;/p&gt;

&lt;p&gt;不过，这也点了我一下——何不把我正在建设中与规划要做的 design-to-code 相关的项目一并打包成「Fxxk Design」呢？这样既有逼格又让人能够大概知道我的那些东西是要解决哪些方面问题的。我这土鳖黑钢级直男码农终于学会了「概念包装」，真是谢谢它们了啊！&lt;/p&gt;

&lt;p&gt;对我来说，那两个 UI 组件库几乎没什么亮点，但各自又分别有一点引起了我的注意——其中一个提到的「Foundation + Adapter」模式和另一个将 UI 组件等单独发包打造物料市场的做法——这些与我在做和要做的事情十分贴近。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;业界现状&lt;/h2&gt;

&lt;p&gt;在说「Fxxk Design」之前，先来梳理下当前流行 UI 组件库的一些特点——&lt;/p&gt;

&lt;p&gt;最直观的就是，与某个技术栈进行了深度绑定，并以一整个 UI 组件集合的形式提供给使用者。人们在交流时所用的语言描述是「React/Vue 的 UI 组件库 XXX」，而不是「XXX 组件」。&lt;/p&gt;

&lt;p&gt;可以说，这是一种「单体架构」，如果某个 UI 组件新增了特性或修复了 bug，需要组件库整体升级，想要以组件粒度进行升级是不可能的。并且，就算是在相同技术栈上，不同组件库间的无缝迁移也是不存在的。&lt;/p&gt;

&lt;p&gt;另外，那些 UI 组件库自身限死了端的形态——桌面端 UI 组件库、移动端 UI 组件库。&lt;/p&gt;

&lt;p&gt;当前流行的 UI 组件库，普遍定制能力较差，主要体现在两方面：没有风格变量或粒度不够，导致无法定制风格或定制很有限；行为的定制也是同理，同时也是它们限死端的形态的原因之一。&lt;/p&gt;

&lt;p&gt;由于定制能力差，再加上上文所述情况，不具备打造物料市场的条件，从而形成不了以它们为中心的生态系统。&lt;/p&gt;

&lt;p&gt;它们的设计在我看来大多不够「原子」，不够「纯粹」——如 &lt;code&gt;Input&lt;/code&gt; 组件把实质上不是同一个东西的通过 &lt;code&gt;type&lt;/code&gt; 属性去控制具体的展示形态；如 &lt;code&gt;Button&lt;/code&gt; 组件拥有值为 &lt;code&gt;primary&lt;/code&gt;、&lt;code&gt;text&lt;/code&gt; 等的 &lt;code&gt;type&lt;/code&gt; 这种与其自然特性毫无关联的属性——这样的设计很容易让一个 UI 组件在多方面显得「臃肿」、「笨重」。&lt;/p&gt;

&lt;p&gt;文档也千篇一律地列 API、放 demo，几乎不会去详细地阐述某个 UI 组件适用于哪些场景，有什么局限性——缺少组件粒度的 UX/UI 设计模式等指导性内容。&lt;/p&gt;

&lt;p&gt;还有一点比较「国内特色」——提供面向中后台场景的「Pro」。多数「Pro」是免费使用的，可就是有那么几个不仅质量不咋样，还需要购买授权才能够用。&lt;/p&gt;

&lt;h2 id=&quot;fxxk-design&quot;&gt;Fxxk Design&lt;/h2&gt;

&lt;p&gt;如文章开头所说，「Fxxk Design」是将以 design-to-code 为目标的相关项目进行打包的「概念」，就像一个专门用来装书的箱子。&lt;/p&gt;

&lt;p&gt;「Fxxk Design」不单要解决 design-to-code 相关问题，还是更大愿景的一部分，因此该体系下的项目将采用分层、松耦合的架构作为基本原则。&lt;/p&gt;

&lt;p&gt;下图为目前「Fxxk Design」的部分架构——&lt;/p&gt;

&lt;figure&gt;
  &lt;img src=&quot;{{ &#39;posts/20211031/architecture-of-petals-and-kokiri&#39; | asset_path }}&quot; alt=&quot;Petals 与 Kokiri&quot; /&gt;
  &lt;figcaption&gt;Petals 与 Kokiri&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;图中所示架构的思想在「&lt;a href=&quot;/series/talking-about-frontend-ui-components/&quot;&gt;聊聊前端 UI 组件&lt;/a&gt;」系列文章中已经说明，这里不再赘述。可以看出，整体分为底层的 Petals 和上层的 Kokiri 这两大部分。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;建设中的&lt;/h3&gt;

&lt;p&gt;Petals 和 Kokiri 皆为正在建设中的项目，它们是文章《&lt;a href=&quot;/posts/the-system-of-frontend-ui-components/&quot;&gt;聊聊前端 UI 组件：组件体系&lt;/a&gt;》中所述思想的实践——&lt;/p&gt;

&lt;p&gt;Petals 作为 UI 组件的基础设施、UI 组件的灵魂而存在，主要包含了「风格组件」（由 Sass 变量与 CSS 自定义属性定义的主题风格变量）、「视觉组件」（CSS 规则集）和「无头组件」（无 DOM 操作的纯计算逻辑）等。&lt;/p&gt;

&lt;p&gt;文中提到的「结构组件」实际上就是 React、Vue 等生成视图结构的库/框架与「视觉组件」和「无头组件」等之间的连接器，属于适配层——Kokiri 就是这么一个角色，专门负责对接 Vue 及基于它的 UI 组件库。&lt;/p&gt;

&lt;p&gt;在 Kokiri 的内部又分为了两层——把 Vue 与「视觉组件」和「无头组件」等进行连接的 &lt;code&gt;@kokiri/core&lt;/code&gt;；将 Petals 中定义的 API 之类适配到现有 UI 组件库的 &lt;code&gt;@kokiri/element&lt;/code&gt;、&lt;code&gt;@kokiri/view-ui&lt;/code&gt; 等。&lt;/p&gt;

&lt;p&gt;除了这些，由于现有 UI 组件库中所提供的 UI 组件无法完全覆盖 Petals 中定义的，因而又自己实现了一套 UI 组件——&lt;code&gt;kokiri&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;综上所述，关于跨运行环境的问题，在该体系下目前有两种适配方案：像 &lt;code&gt;@kokiri/core&lt;/code&gt; 这种跨技术栈；再就像 &lt;code&gt;@kokiri/element&lt;/code&gt;、&lt;code&gt;@kokiri/view-ui&lt;/code&gt; 一样跨组件库。&lt;/p&gt;

&lt;p&gt;也就是说，如果要支持新的技术栈或新的 UI 组件库，只要像上面所说那样做就好。&lt;/p&gt;

&lt;p&gt;另外，Petals 中除了与 UI 组件直接相关的基础设施，还集成了 Nicolas Gallagher 的 normalize.css 和 SUIT CSS 相关样式，以及 Compass 的 function、mixin 等。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;规划中的&lt;/h3&gt;

&lt;p&gt;Petals 和 Kokiri 之类所起到的作用只能算是 UI 组件体系中的基本操作，要想对 design-to-code 产生更大价值，就得打造丰富的物料市场并与 UX/UI 设计环节打通。&lt;/p&gt;

&lt;p&gt;物料市场中不仅有单独的 UI 组件，还有 UI 组件集合、UI 组件库适配器、主题风格等等。&lt;/p&gt;

&lt;p&gt;规划中要做的新版 Buds 的定位中就包括了对物料市场的支持这部分——UI 组件的开发、调试、打包、发布等。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;与当前业界的普遍做法不太一样，「Fxxk Design」追求的是原子化、松耦合的设计，这样一来，很容易做到跨运行环境，如：技术栈、UI 组件库等。&lt;/p&gt;

&lt;p&gt;该体系下的 UI 组件都单独发包，能够以组件粒度独立升级。&lt;/p&gt;

&lt;p&gt;由于可定制性较强，主题风格的变换、桌面端与移动端兼容、物料市场的打造等都相对更容易些。&lt;/p&gt;

&lt;p&gt;最后，「Fxxk Design」不提供所谓的「Pro」，对中后台场景的支持由「Future.js」体系提供。&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Oct 2021 20:57:35 +0800</pubDate>
        <link>https://ourai.ws/posts/fxxk-design-from-anti-chaos/</link>
        <guid isPermaLink="true">https://ourai.ws/posts/fxxk-design-from-anti-chaos/</guid>
        
        <category>open-source</category>
        
        
        <category>frontend-web-development</category>
        
        <category>frontend-engineering</category>
        
        <category>open-source-software</category>
        
        <category>anti-chaos</category>
        
        <category>fxxk-design</category>
        
      </item>
    
      <item>
        <title>说说「反混沌」：Hello, World!</title>
        
          <dc:creator>欧雷</dc:creator>
          <author>欧雷</author>
        
        <description>&lt;p&gt;「反混沌」，英文是「Anti-chaos」，简称为「NTKS」，是一种思想，是一个计划，是一个体系，是一个组织，也是一个社区。&lt;/p&gt;

&lt;p&gt;我多次在网上、现实中跟别人有意无意地提起过「反混沌」，但一直都没有详细地说过它到底是个什么东西以及搞它的意义是什么；因而出现了这篇文章，让那些疑惑的和有可能感兴趣的人了解它。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;为啥要「反混沌」&lt;/h2&gt;

&lt;p&gt;各位，看到我下面列出的一些情况，你们是否会感同身受——&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;团队协作&lt;/h3&gt;

&lt;p&gt;新加入一个团队了解下项目代码后发现，在使用 Vue 组件时模板中的组件名和属性有的是驼峰式有的是肉串式，甚至同一个组件同时存在两种命名。&lt;/p&gt;

&lt;p&gt;函数名和返回值数据类型之间貌似找不到什么联系，或者函数体所做的事情已经超出了函数名所表达的范围，让人无法顾名思义。&lt;/p&gt;

&lt;p&gt;看过之后，忍不住在心里默默地嘲讽道：「这都写的什么烂代码！简直是屎！！」&lt;/p&gt;

&lt;p&gt;自己不想跳进这 sea of shit，并且作为新人，得要证明自己在团队中的价值。多年经验和知识的积累，深知要想团队变好，「规范化」是第一阶段中的第一步，也就是定规则、立规矩。&lt;/p&gt;

&lt;p&gt;在吭哧吭哧把各种规范、约定的草稿拟出来并开会讨论确定之后，发现真正执行时并不会有多大改善——原来怎么写，基本还那么写……&lt;/p&gt;

&lt;p&gt;这让你更加确定了自己对人性的认知——自觉？狗屁！力量才是一切！人会犯错，再靠谱，也不如机器/程序来得靠谱！&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;可复用性&lt;/h3&gt;

&lt;p&gt;在工作中接到一个比较复杂的需求，虽然有相关的开源项目，但比较少，并且可扩展性都有问题，要满足业务需求只能在它们基础上魔改或从零开发。&lt;/p&gt;

&lt;p&gt;公司/部门开辟新业务，需要做个新应用，前端很多东西理应是可以复用的，可实际在复用时要改很多东西，改到怀疑人生……&lt;/p&gt;

&lt;p&gt;前端库/框架更迭太快，正在维护的应用太庞大了，核心逻辑与视图层过于耦合，想升级下技术太难了，简直是伤筋动骨。&lt;/p&gt;

&lt;p&gt;公司/部门里用了不止一个技术栈，它们的使用方式天差地别，如果被安排去做一个跑在不了解的技术栈之上的应用的需求，不仅要花时间理解业务，还要去了解那个技术栈的玩法，切换技术栈成本有点高。&lt;/p&gt;

&lt;p&gt;想把原本用 Vue 2.x 写的应用整体升级到 Vue 3.x，可是在用的 Element 不支持 Vue 3.x，并且&lt;a href=&quot;https://www.zhihu.com/question/407326156&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;官方也已经（间接）宣布不再继续维护 Element&lt;/a&gt;，该咋办？！就算它有 Vue 3.x 版本的，能顺滑地迁移过去吗？另外，再遇到类似的情况，如何降低升级、迁移成本？&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;「反混沌」的愿景&lt;/h2&gt;

&lt;p&gt;上面列举的几个是很常见的问题，相信各位跟我一样想要极力去避免掉。引起这些问题的因素，都可以归结为一个词——混沌——无序、模糊不清的一种状态，会导致混乱，从而使工作变得困难。&lt;/p&gt;

&lt;p&gt;「混沌」的根源不是别的，正是「人」自身，主要体现在两个方面：人性的缺点所引起的协作与管理问题；信息在传递过程中会失真。&lt;/p&gt;

&lt;p&gt;有的人会想要不合时宜的自由，如：虽然有规范，虽然某件事在客观上就是不恰当的，会让程序变得不稳定、不好维护或影响团队氛围，但自己就是不想被束缚，就是要按照自己舒服的来。&lt;/p&gt;

&lt;p&gt;有的人总想着偷懒，能少做点就少做点，对自己代码的质量概不负责，能跑就行，就算那代表着自己的脸面也不管不顾。也许勤去叮嘱着些代码质量会稍微好点儿，但时间长了谁都累。&lt;/p&gt;

&lt;p&gt;软件开发过程就是从接到需求到产出符合需求的可用软件的过程。在这一整个链条中，源头是需求提出方，然后经过产品、设计、开发、测试等不同岗位的人处理。&lt;/p&gt;

&lt;p&gt;虽说源头是需求方，但更实际的源头是需求方的意愿。这个「意愿」是不是「真（true）」的，首先要打个问号。然后信息在传递过程中肯定会有所损失，每个传递的节点能力越差损失得越多。&lt;/p&gt;

&lt;p&gt;信息在每个人那里输入、输出时，因为知识、理解力、表达力等因素，多多少少都会发生变形，为了尽可能「保真」，必然的选择就是减少传递环节，也就是减少参与人数，尽最大可能让需求方的意愿直接变成符合需求的可用软件。&lt;/p&gt;

&lt;p&gt;软件开发中的「混沌」需要被治理，「反混沌」即为盘古及其手执之斧——劈开混沌，清者为天，浊者为地。&lt;/p&gt;

&lt;p&gt;因此，「反混沌」的宗旨就是——通过促进前端工业化进程，从而让前端开发更加有序，让业务开发专注业务，为新型开发方式及协作模式做支撑。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;「反混沌」的内涵&lt;/h2&gt;

&lt;p&gt;在本文开头说了「反混沌」——&lt;/p&gt;

&lt;p&gt;「是一种思想」——对前端及其相关事物的无序、混乱的现状强烈不满，执着于打造一个有序的，不去做无意义或重复事情的，尽可能做自己喜欢做且对行业有价值事情的环境。&lt;/p&gt;

&lt;p&gt;「是一个计划」——打算在软件设计、团队协作等方面进行一些分享，并从前端工程、应用开发等角度提供一些实用工具，帮助消除「混沌」。&lt;/p&gt;

&lt;p&gt;「是一个体系」——实施上述「计划」的一系列举措，当前在前端工程、应用开发方面有「Fxxk Design」和「Future.js」两大子体系。&lt;/p&gt;

&lt;p&gt;「是一个组织」——独自一人，就算能力再大，也难以成事，因而需要几个高度志同道合且能力优秀的人组成核心团队，共同完成使命。&lt;/p&gt;

&lt;p&gt;「是一个社区」——打从心底想为行业做些有意义、有价值的事情，因此拥抱开源，打造以非盈利个人/组织为主导的优质开源社区。&lt;/p&gt;

&lt;p&gt;其实说到底，「反混沌」的本质是前端及其相关事物各个层次、各个环节之间通信的「事实标准」。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;我这土鳖黑钢级直男码农写不出什么华丽的词藻，也做不出酷炫的 PPT，只能用这最质朴的文字来大概勾勒下我朴素的「反混沌」。&lt;/p&gt;

&lt;p&gt;我深知要去做「反混沌」这件事很难，也会遭受一群人的冷嘲热讽，但我已经做好了觉悟——以创业的心态去经营与探索。&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Oct 2021 23:48:26 +0800</pubDate>
        <link>https://ourai.ws/posts/hello-world-from-anti-chaos/</link>
        <guid isPermaLink="true">https://ourai.ws/posts/hello-world-from-anti-chaos/</guid>
        
        <category>open-source</category>
        
        
        <category>frontend-web-development</category>
        
        <category>frontend-engineering</category>
        
        <category>open-source-software</category>
        
        <category>anti-chaos</category>
        
      </item>
    
  </channel>
</rss>
