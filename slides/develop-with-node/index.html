<!DOCTYPE html> <html lang="zh-CN" dir="ltr"> <head> <meta charset="UTF-8"> <!-- SEO --> <title>用 Node.js 去开发应用</title> <meta property="og:title" content="用 Node.js 去开发应用"> <meta name="description" content=" 这些年…… 好多人在说 Node.js 听起来很屌的样子 但是，它都能做些什么呢？ 据某人统计 Node.js 可以用到以下这些场景 命令行工具、Web 服务器、游戏服务器、爬虫、实时 APP、聊天机器人、CMS、图片处理、桌面应用…… 想知道还能干啥？ 那就要看你的脑洞有多大了 还是让我们先来聊聊几个最常用的场景吧 编写通用模块 每个 node 应用都是一个「包」 而「通用模块」就是一种最简单、最基础、最通用的包 主要作用是供其他更为复杂、庞大的应用调用 要开发一个包 需要在应用的根目录建一个 package.json 文件 用来记述这个应用的相关信息 它基本是长成这个样子 { &quot;name&quot;: &quot;rocketz-core&quot;, &quot;version&quot;: &quot;1.0.3&quot;, &quot;description&quot;: &quot;Upload local files to OSSs&quot;, &quot;homepage&quot;: &quot;https://github.com/ourai/rocketz&quot;, &quot;keywords&quot;: [&quot;rocketz&quot;, &quot;uploader&quot;, &quot;upload&quot;, &quot;oss&quot;, &quot;cloud&quot;], &quot;author&quot;: &quot;Ourai Lin &lt;ourairyu@hotmail.com&gt; (http://ourai.ws/)&quot;, &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/ourai/rocketz.git&quot; }, &quot;bugs&quot;: &quot;https://github.com/ourai/rocketz/issues&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;prebuild&quot;: &quot;mv lib src&quot;, &quot;build&quot;: &quot;babel src -d lib --presets=es2015&quot;, &quot;prepublish&quot;: &quot;npm run build&quot;, &quot;postpublish&quot;: &quot;rm -rf lib &amp;&amp; mv src lib&quot; }, &quot;devDependencies&quot;: { &quot;babel-cli&quot;: &quot;^6.9.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.9.0&quot; }, &quot;dependencies&quot;: { &quot;lodash&quot;: &quot;^4.1.0&quot;, &quot;rocketz-register&quot;: &quot;^0.1.1&quot; }, &quot;license&quot;: &quot;MIT&quot;} 在入口文件 index.js 中写几行代码 // 定义一个 OSS 信息const OSS_INFO = { qiniu: {name: &quot;七牛&quot;}, wantu: {name: &quot;顽兔&quot;} };// 暴露出获取指定 OSS 信息的方法exports.getOss = function( ossName ) { return OSS_INFO[ossName] || {};}; 就完成了一个最「简陋」的包 在其他包中引用一下就可以调用其中定义的方法了 // 引入通用模块const rocketz = require(&quot;rocketz-core&quot;);// 调用方法console.log(rocketz.getOss(&quot;qiniu&quot;)); // 输出 {name: &quot;七牛&quot;} 命令行工具 这是一种较为高级的 node 应用 它是通过命令行调用的程序 如 rocketz init 命令行工具与通用模块的不同之处在于 不可被其他包引用 需要在 package.json 中指定 &quot;bin&quot; 针对命令和 flag 的处理逻辑 其中，如果直接写成 { &quot;bin&quot;: &quot;./bin/rocketz.js&quot;} 将会以包的名字作为命令名 要想命令名不同于包名或存在多个命令 就要明确写出命令的名字 { &quot;bin&quot;: { &quot;rocketz&quot;: &quot;./bin/rocketz.js&quot; }} 完全自己去写命令和 flag 的处理逻辑是件让人蛋碎的事情 还好已经有一些第三方包可以起到辅助作用 我主要用到了三个包 meow lift inquirer 偷懒万岁！*\(^o^)/* meow 的主要作用有 将命令和 flag 分别转化为数组和对象以便于读取 自动生成 --version 和 --help 这两个 flag 设置 flag 的别名 meow 的用法很简单 const meow = require(&quot;meow&quot;);const helper = meow({}, { alias: { h: &quot;help&quot;, v: &quot;version&quot; }}); 如果在命令行中输入 rocketz init qiniu --config wantu 程序中调用 helper.input 和 helper.flags console.log(helper.input); // 输出 [&quot;init&quot;, &quot;qiniu&quot;]console.log(helper.flags); // 输出 {config: &quot;wantu&quot;} liftoff 主要解决了几件事情 定义、查找并读取配置文件 作为命令处理的入口 liftoff 的用法也较为简单 const Liftoff = require(&quot;liftoff&quot;);const APP_NAME = &quot;rocketz&quot;;const app = new Liftoff({ name: APP_NAME, configName: `.${APP_NAME}`, extensions: { &quot;rc&quot;: null }});// 启动应用app.launch({ cwd: process.cwd(), configPath: __dirname }, function( env ) { // 命令和 flag 的处理逻辑}); inquirer 可以让你设置一些「问答题」 通过在命令行中的一步步操作 完成对配置文件内容的设置 meow＋liftoff＋inquirer＝一个完整的命令行工具 服务端开发 这是另一种较高级的 node 应用 也是给前端带来新希望的一种应用 做服务端开发离不开 web 框架 在我眼里总共有两种类型 全栈式 REST 所谓的「全栈式」框架 就是完整地提供了 MVC 支持的框架 轻量点的有 Express、Koa 它们都太轻量 以至于需要自己去东拼西凑成一套完整的框架 不太适合快速开发 有个叫做 Sails 的框架 看名字也许会想到了什么 没错，就是那辆小火车 这是一个借鉴 Ruby on Rails 的大而全的框架 挺适合快速开发的 然而，在现在这种多终端的使用环境下 全栈式的框架显得不那么灵活 服务端只需要通过 API 接口提供数据就好了 restify 就是为此而生 Node.js 改变了我 让我从纯前端渐渐转变为可以贯穿 web 栈的伪·全栈 我的废话说完了 谢谢！"> <meta property="og:description" content=" 这些年…… 好多人在说 Node.js 听起来很屌的样子 但是，它都能做些什么呢？ 据某人统计 Node.js 可以用到以下这些场景 命令行工具、Web 服务器、游戏服务器、爬虫、实时 APP、聊天机器人、CMS、图片处理、桌面应用…… 想知道还能干啥？ 那就要看你的脑洞有多大了 还是让我们先来聊聊几个最常用的场景吧 编写通用模块 每个 node 应用都是一个「包」 而「通用模块」就是一种最简单、最基础、最通用的包 主要作用是供其他更为复杂、庞大的应用调用 要开发一个包 需要在应用的根目录建一个 package.json 文件 用来记述这个应用的相关信息 它基本是长成这个样子 { &quot;name&quot;: &quot;rocketz-core&quot;, &quot;version&quot;: &quot;1.0.3&quot;, &quot;description&quot;: &quot;Upload local files to OSSs&quot;, &quot;homepage&quot;: &quot;https://github.com/ourai/rocketz&quot;, &quot;keywords&quot;: [&quot;rocketz&quot;, &quot;uploader&quot;, &quot;upload&quot;, &quot;oss&quot;, &quot;cloud&quot;], &quot;author&quot;: &quot;Ourai Lin &lt;ourairyu@hotmail.com&gt; (http://ourai.ws/)&quot;, &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/ourai/rocketz.git&quot; }, &quot;bugs&quot;: &quot;https://github.com/ourai/rocketz/issues&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;prebuild&quot;: &quot;mv lib src&quot;, &quot;build&quot;: &quot;babel src -d lib --presets=es2015&quot;, &quot;prepublish&quot;: &quot;npm run build&quot;, &quot;postpublish&quot;: &quot;rm -rf lib &amp;&amp; mv src lib&quot; }, &quot;devDependencies&quot;: { &quot;babel-cli&quot;: &quot;^6.9.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.9.0&quot; }, &quot;dependencies&quot;: { &quot;lodash&quot;: &quot;^4.1.0&quot;, &quot;rocketz-register&quot;: &quot;^0.1.1&quot; }, &quot;license&quot;: &quot;MIT&quot;} 在入口文件 index.js 中写几行代码 // 定义一个 OSS 信息const OSS_INFO = { qiniu: {name: &quot;七牛&quot;}, wantu: {name: &quot;顽兔&quot;} };// 暴露出获取指定 OSS 信息的方法exports.getOss = function( ossName ) { return OSS_INFO[ossName] || {};}; 就完成了一个最「简陋」的包 在其他包中引用一下就可以调用其中定义的方法了 // 引入通用模块const rocketz = require(&quot;rocketz-core&quot;);// 调用方法console.log(rocketz.getOss(&quot;qiniu&quot;)); // 输出 {name: &quot;七牛&quot;} 命令行工具 这是一种较为高级的 node 应用 它是通过命令行调用的程序 如 rocketz init 命令行工具与通用模块的不同之处在于 不可被其他包引用 需要在 package.json 中指定 &quot;bin&quot; 针对命令和 flag 的处理逻辑 其中，如果直接写成 { &quot;bin&quot;: &quot;./bin/rocketz.js&quot;} 将会以包的名字作为命令名 要想命令名不同于包名或存在多个命令 就要明确写出命令的名字 { &quot;bin&quot;: { &quot;rocketz&quot;: &quot;./bin/rocketz.js&quot; }} 完全自己去写命令和 flag 的处理逻辑是件让人蛋碎的事情 还好已经有一些第三方包可以起到辅助作用 我主要用到了三个包 meow lift inquirer 偷懒万岁！*\(^o^)/* meow 的主要作用有 将命令和 flag 分别转化为数组和对象以便于读取 自动生成 --version 和 --help 这两个 flag 设置 flag 的别名 meow 的用法很简单 const meow = require(&quot;meow&quot;);const helper = meow({}, { alias: { h: &quot;help&quot;, v: &quot;version&quot; }}); 如果在命令行中输入 rocketz init qiniu --config wantu 程序中调用 helper.input 和 helper.flags console.log(helper.input); // 输出 [&quot;init&quot;, &quot;qiniu&quot;]console.log(helper.flags); // 输出 {config: &quot;wantu&quot;} liftoff 主要解决了几件事情 定义、查找并读取配置文件 作为命令处理的入口 liftoff 的用法也较为简单 const Liftoff = require(&quot;liftoff&quot;);const APP_NAME = &quot;rocketz&quot;;const app = new Liftoff({ name: APP_NAME, configName: `.${APP_NAME}`, extensions: { &quot;rc&quot;: null }});// 启动应用app.launch({ cwd: process.cwd(), configPath: __dirname }, function( env ) { // 命令和 flag 的处理逻辑}); inquirer 可以让你设置一些「问答题」 通过在命令行中的一步步操作 完成对配置文件内容的设置 meow＋liftoff＋inquirer＝一个完整的命令行工具 服务端开发 这是另一种较高级的 node 应用 也是给前端带来新希望的一种应用 做服务端开发离不开 web 框架 在我眼里总共有两种类型 全栈式 REST 所谓的「全栈式」框架 就是完整地提供了 MVC 支持的框架 轻量点的有 Express、Koa 它们都太轻量 以至于需要自己去东拼西凑成一套完整的框架 不太适合快速开发 有个叫做 Sails 的框架 看名字也许会想到了什么 没错，就是那辆小火车 这是一个借鉴 Ruby on Rails 的大而全的框架 挺适合快速开发的 然而，在现在这种多终端的使用环境下 全栈式的框架显得不那么灵活 服务端只需要通过 API 接口提供数据就好了 restify 就是为此而生 Node.js 改变了我 让我从纯前端渐渐转变为可以贯穿 web 栈的伪·全栈 我的废话说完了 谢谢！"> <meta name="keywords" content="欧雷,欧雷流,黑客,软件工程师,前端工程师,前端开发,前端工程,日本,日语,日本文化,个人风格,博客,日记,思考,ourai,ourairyu"> <link rel="canonical" href="https://ourai.ws/slides/develop-with-node/"> <meta property="og:url" content="https://ourai.ws/slides/develop-with-node/"> <meta property="og:site_name" content="欧雷流"> <script type="application/ld+json"> { "@context" : "http://schema.org", "@type" : "WebSite", "name" : "欧雷流", "url" : "https://ourai.ws" } </script> <meta property="og:image" content="https://ourai.ws/assets/slides/develop-with-node/cover-8ffc4b283e95e3104bd4407cf93c30b9d4ddcfb3c293a4340c64276cbeaff3f2.jpg"> <meta property="og:type" content="article"> <meta property="article:published_time" content="2025-01-24T21:59:39+08:00"> <link rel="prev" href="https://ourai.ws/slides/decoupling-web-architecture/" title="浅谈「前后端分离」"> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "NewsArticle", "headline": "用 Node.js 去开发应用", "image": "/assets/slides/develop-with-node/cover-8ffc4b283e95e3104bd4407cf93c30b9d4ddcfb3c293a4340c64276cbeaff3f2.jpg", "datePublished": "2025-01-24T21:59:39+08:00", "description": " 这些年…… 好多人在说 Node.js 听起来很屌的样子 但是，它都能做些什么呢？ 据某人统计 Node.js 可以用到以下这些场景 命令行工具、Web 服务器、游戏服务器、爬虫、实时 APP、聊天机器人、CMS、图片处理、桌面应用…… 想知道还能干啥？ 那就要看你的脑洞有多大了 还是让我们先来聊聊几个最常用的场景吧 编写通用模块 每个 node 应用都是一个「包」 而「通用模块」就是一种最简单、最基础、最通用的包 主要作用是供其他更为复杂、庞大的应用调用 要开发一个包 需要在应用的根目录建一个 package.json 文件 用来记述这个应用的相关信息 它基本是长成这个样子 { &quot;name&quot;: &quot;rocketz-core&quot;, &quot;version&quot;: &quot;1.0.3&quot;, &quot;description&quot;: &quot;Upload local files to OSSs&quot;, &quot;homepage&quot;: &quot;https://github.com/ourai/rocketz&quot;, &quot;keywords&quot;: [&quot;rocketz&quot;, &quot;uploader&quot;, &quot;upload&quot;, &quot;oss&quot;, &quot;cloud&quot;], &quot;author&quot;: &quot;Ourai Lin &lt;ourairyu@hotmail.com&gt; (http://ourai.ws/)&quot;, &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/ourai/rocketz.git&quot; }, &quot;bugs&quot;: &quot;https://github.com/ourai/rocketz/issues&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;prebuild&quot;: &quot;mv lib src&quot;, &quot;build&quot;: &quot;babel src -d lib --presets=es2015&quot;, &quot;prepublish&quot;: &quot;npm run build&quot;, &quot;postpublish&quot;: &quot;rm -rf lib &amp;&amp; mv src lib&quot; }, &quot;devDependencies&quot;: { &quot;babel-cli&quot;: &quot;^6.9.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.9.0&quot; }, &quot;dependencies&quot;: { &quot;lodash&quot;: &quot;^4.1.0&quot;, &quot;rocketz-register&quot;: &quot;^0.1.1&quot; }, &quot;license&quot;: &quot;MIT&quot;} 在入口文件 index.js 中写几行代码 // 定义一个 OSS 信息const OSS_INFO = { qiniu: {name: &quot;七牛&quot;}, wantu: {name: &quot;顽兔&quot;} };// 暴露出获取指定 OSS 信息的方法exports.getOss = function( ossName ) { return OSS_INFO[ossName] || {};}; 就完成了一个最「简陋」的包 在其他包中引用一下就可以调用其中定义的方法了 // 引入通用模块const rocketz = require(&quot;rocketz-core&quot;);// 调用方法console.log(rocketz.getOss(&quot;qiniu&quot;)); // 输出 {name: &quot;七牛&quot;} 命令行工具 这是一种较为高级的 node 应用 它是通过命令行调用的程序 如 rocketz init 命令行工具与通用模块的不同之处在于 不可被其他包引用 需要在 package.json 中指定 &quot;bin&quot; 针对命令和 flag 的处理逻辑 其中，如果直接写成 { &quot;bin&quot;: &quot;./bin/rocketz.js&quot;} 将会以包的名字作为命令名 要想命令名不同于包名或存在多个命令 就要明确写出命令的名字 { &quot;bin&quot;: { &quot;rocketz&quot;: &quot;./bin/rocketz.js&quot; }} 完全自己去写命令和 flag 的处理逻辑是件让人蛋碎的事情 还好已经有一些第三方包可以起到辅助作用 我主要用到了三个包 meow lift inquirer 偷懒万岁！*\\(^o^)/* meow 的主要作用有 将命令和 flag 分别转化为数组和对象以便于读取 自动生成 --version 和 --help 这两个 flag 设置 flag 的别名 meow 的用法很简单 const meow = require(&quot;meow&quot;);const helper = meow({}, { alias: { h: &quot;help&quot;, v: &quot;version&quot; }}); 如果在命令行中输入 rocketz init qiniu --config wantu 程序中调用 helper.input 和 helper.flags console.log(helper.input); // 输出 [&quot;init&quot;, &quot;qiniu&quot;]console.log(helper.flags); // 输出 {config: &quot;wantu&quot;} liftoff 主要解决了几件事情 定义、查找并读取配置文件 作为命令处理的入口 liftoff 的用法也较为简单 const Liftoff = require(&quot;liftoff&quot;);const APP_NAME = &quot;rocketz&quot;;const app = new Liftoff({ name: APP_NAME, configName: `.${APP_NAME}`, extensions: { &quot;rc&quot;: null }});// 启动应用app.launch({ cwd: process.cwd(), configPath: __dirname }, function( env ) { // 命令和 flag 的处理逻辑}); inquirer 可以让你设置一些「问答题」 通过在命令行中的一步步操作 完成对配置文件内容的设置 meow＋liftoff＋inquirer＝一个完整的命令行工具 服务端开发 这是另一种较高级的 node 应用 也是给前端带来新希望的一种应用 做服务端开发离不开 web 框架 在我眼里总共有两种类型 全栈式 REST 所谓的「全栈式」框架 就是完整地提供了 MVC 支持的框架 轻量点的有 Express、Koa 它们都太轻量 以至于需要自己去东拼西凑成一套完整的框架 不太适合快速开发 有个叫做 Sails 的框架 看名字也许会想到了什么 没错，就是那辆小火车 这是一个借鉴 Ruby on Rails 的大而全的框架 挺适合快速开发的 然而，在现在这种多终端的使用环境下 全栈式的框架显得不那么灵活 服务端只需要通过 API 接口提供数据就好了 restify 就是为此而生 Node.js 改变了我 让我从纯前端渐渐转变为可以贯穿 web 栈的伪·全栈 我的废话说完了 谢谢！" } </script> <script type="application/ld+json"> { "@context" : "http://schema.org", "@type" : "person", "name" : "欧雷流", "url" : "https://ourai.ws", "sameAs" : null } </script> <link rel="author" href="https://ourai.ws"> <!-- 页面渲染兼容性 --> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="renderer" content="webkit"> <meta name="viewport" content="width=device-width,initial-scale=1.0"> <!-- 订阅 --> <link type="application/atom+xml" rel="alternate" href="https://ourai.ws/atom.xml" title="欧雷流" /> <link type="application/rss+xml" rel="alternate" href="//ourai.ws/rss.xml" title="欧雷流"> <meta name="theme-color" content="#0871ab"> <link rel="icon" href="/assets/favicon-3e749ca030e3b71eb2662d947c789061d2da9e0f4ee5f3360cfa9ccbe053c8ba.ico"> <!-- 静态资源 --> <link type="text/css" rel="stylesheet" href="/assets/disqusjs.min-b077139304675330d06888b873bd88158951637593a3c17c4674bc855caf71af.css"> <link type="text/css" rel="stylesheet" href="/assets/global-b623500154e70cdef18bd463a0ef409c46da6d1ad99756cf169ddb354874bcbc.css"> <link type="text/css" rel="stylesheet" href="/assets/pages/slide-0d52d2d0fc19e97eb383ab4e5ad21815cef56c6f0c224f088f3cf548b34b55ea.css"> <script type="text/javascript" src="/assets/statistic-ae0fea4509b55747b1bcc6318c58abf5817e03e26505a307f438b42f0c6783bc.js"></script> <script type="text/javascript" src="/assets/global-b3a80dd53acf48ad7228d6fd741dba15d3845cbc3783bdbbf7244151a45628aa.js"></script> <!--[if lt IE 9]> <script type="text/javascript" src="/assets/support_ie8-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.js"></script> <![endif]--> </head> <body class="Page" itemscope itemtype="http://schema.org/WebPage"> <main class="reveal"> <div class="slides"> <section data-background-image="/assets/slides/develop-with-node/cover-8ffc4b283e95e3104bd4407cf93c30b9d4ddcfb3c293a4340c64276cbeaff3f2.jpg" data-transition="fade-out"></section> <section data-transition="fade-in"> <h2>用 Node.js 去开发应用</h2> <p><a href="https://ourai.ws/">欧雷</a></p> </section> <section> <p>这些年……</p> <p class="fragment">好多人在说 Node.js</p> <p class="fragment">听起来很屌的样子</p> <p class="fragment">但是<span class="fragment">，它都能做些什么呢？</span></p> </section> <section> <p>据某人统计</p> <p class="fragment">Node.js 可以用到以下这些场景</p> <blockquote class="fragment">命令行工具<span class="fragment">、Web 服务器</span><span class="fragment">、游戏服务器</span><span class="fragment">、爬虫</span><span class="fragment">、实时 APP</span><span class="fragment">、聊天机器人</span><span class="fragment">、CMS</span><span class="fragment">、图片处理</span><span class="fragment">、桌面应用</span><span class="fragment">……</span></blockquote> <p class="fragment">想知道还能干啥？</p> <p class="fragment">那就要看你的脑洞有多大了</p> </section> <section> <p>还是让我们先来聊聊几个最常用的场景吧</p> </section> <!-- 编写通用模块 --> <section> <section> <h2>编写通用模块</h2> <p class="fragment">每个 node 应用都是一个「包」</p> <p class="fragment">而「通用模块」就是一种最简单、最基础、最通用的包</p> <p class="fragment">主要作用是供其他更为复杂、庞大的应用调用</p> </section> <section> <p>要开发一个包</p> <p class="fragment">需要在应用的根目录建一个 <code>package.json</code> 文件</p> <p class="fragment">用来记述这个应用的相关信息</p> <p class="fragment">它基本是长成这个样子</p> </section> <section> <figure class="highlight"><pre><code class="language-json" data-lang="json"><span></span><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;rocketz-core&quot;</span><span class="p">,</span>
  <span class="nt">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0.3&quot;</span><span class="p">,</span>
  <span class="nt">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Upload local files to OSSs&quot;</span><span class="p">,</span>
  <span class="nt">&quot;homepage&quot;</span><span class="p">:</span> <span class="s2">&quot;https://github.com/ourai/rocketz&quot;</span><span class="p">,</span>
  <span class="nt">&quot;keywords&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;rocketz&quot;</span><span class="p">,</span> <span class="s2">&quot;uploader&quot;</span><span class="p">,</span> <span class="s2">&quot;upload&quot;</span><span class="p">,</span> <span class="s2">&quot;oss&quot;</span><span class="p">,</span> <span class="s2">&quot;cloud&quot;</span><span class="p">],</span>
  <span class="nt">&quot;author&quot;</span><span class="p">:</span> <span class="s2">&quot;Ourai Lin &lt;ourairyu@hotmail.com&gt; (http://ourai.ws/)&quot;</span><span class="p">,</span>
  <span class="nt">&quot;repository&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;git&quot;</span><span class="p">,</span>
    <span class="nt">&quot;url&quot;</span><span class="p">:</span> <span class="s2">&quot;https://github.com/ourai/rocketz.git&quot;</span>
  <span class="p">},</span>
  <span class="nt">&quot;bugs&quot;</span><span class="p">:</span> <span class="s2">&quot;https://github.com/ourai/rocketz/issues&quot;</span><span class="p">,</span>
  <span class="nt">&quot;main&quot;</span><span class="p">:</span> <span class="s2">&quot;index.js&quot;</span><span class="p">,</span>
  <span class="nt">&quot;scripts&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;prebuild&quot;</span><span class="p">:</span> <span class="s2">&quot;mv lib src&quot;</span><span class="p">,</span>
    <span class="nt">&quot;build&quot;</span><span class="p">:</span> <span class="s2">&quot;babel src -d lib --presets=es2015&quot;</span><span class="p">,</span>
    <span class="nt">&quot;prepublish&quot;</span><span class="p">:</span> <span class="s2">&quot;npm run build&quot;</span><span class="p">,</span>
    <span class="nt">&quot;postpublish&quot;</span><span class="p">:</span> <span class="s2">&quot;rm -rf lib &amp;&amp; mv src lib&quot;</span>
  <span class="p">},</span>
  <span class="nt">&quot;devDependencies&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;babel-cli&quot;</span><span class="p">:</span> <span class="s2">&quot;^6.9.0&quot;</span><span class="p">,</span>
    <span class="nt">&quot;babel-preset-es2015&quot;</span><span class="p">:</span> <span class="s2">&quot;^6.9.0&quot;</span>
  <span class="p">},</span>
  <span class="nt">&quot;dependencies&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;lodash&quot;</span><span class="p">:</span> <span class="s2">&quot;^4.1.0&quot;</span><span class="p">,</span>
    <span class="nt">&quot;rocketz-register&quot;</span><span class="p">:</span> <span class="s2">&quot;^0.1.1&quot;</span>
  <span class="p">},</span>
  <span class="nt">&quot;license&quot;</span><span class="p">:</span> <span class="s2">&quot;MIT&quot;</span>
<span class="p">}</span></code></pre></figure> </section> <section> <p>在入口文件 <code>index.js</code> 中写几行代码</p> <div class="fragment"> <figure class="highlight"><pre><code class="language-js" data-lang="js"><span></span><span class="c1">// 定义一个 OSS 信息</span>
<span class="kd">const</span> <span class="nx">OSS_INFO</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">qiniu</span><span class="o">:</span> <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;七牛&quot;</span><span class="p">},</span>
    <span class="nx">wantu</span><span class="o">:</span> <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;顽兔&quot;</span><span class="p">}</span>
  <span class="p">};</span>
<span class="c1">// 暴露出获取指定 OSS 信息的方法</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">getOss</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">ossName</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">OSS_INFO</span><span class="p">[</span><span class="nx">ossName</span><span class="p">]</span> <span class="o">||</span> <span class="p">{};</span>
<span class="p">};</span></code></pre></figure> </div> <p class="fragment">就完成了一个最「简陋」的包</p> <p class="fragment">在其他包中引用一下<span class="fragment">就可以调用其中定义的方法了</span></p> <div class="fragment"> <figure class="highlight"><pre><code class="language-js" data-lang="js"><span></span><span class="c1">// 引入通用模块</span>
<span class="kd">const</span> <span class="nx">rocketz</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;rocketz-core&quot;</span><span class="p">);</span>
<span class="c1">// 调用方法</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rocketz</span><span class="p">.</span><span class="nx">getOss</span><span class="p">(</span><span class="s2">&quot;qiniu&quot;</span><span class="p">));</span>   <span class="c1">// 输出 {name: &quot;七牛&quot;}</span></code></pre></figure> </div> </section> </section> <!-- 命令行工具 --> <section> <section> <h2>命令行工具</h2> <p class="fragment">这是一种较为高级的 node 应用</p> <p class="fragment">它是通过命令行调用的程序</p> <p class="fragment">如 <code class="fragment">rocketz init</code></p> </section> <!-- 命令行工具的特殊点 --> <section> <p>命令行工具与通用模块的不同之处在于</p> <ol class="fragment"> <li>不可被其他包引用</li> <li class="fragment">需要在 <code>package.json</code> 中指定 <code>"bin"</code></li> <li class="fragment">针对命令和 flag 的处理逻辑</li> </ol> </section> <!-- 命令名字 --> <section> <p>其中，如果直接写成</p> <figure class="highlight"><pre><code class="language-json" data-lang="json"><span></span><span class="p">{</span>
  <span class="nt">&quot;bin&quot;</span><span class="p">:</span> <span class="s2">&quot;./bin/rocketz.js&quot;</span>
<span class="p">}</span></code></pre></figure> <p class="fragment">将会以包的名字作为命令名</p> <p class="fragment">要想命令名不同于包名或存在多个命令</p> <p class="fragment">就要明确写出命令的名字</p> <div class="fragment"><figure class="highlight"><pre><code class="language-json" data-lang="json"><span></span><span class="p">{</span>
  <span class="nt">&quot;bin&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;rocketz&quot;</span><span class="p">:</span> <span class="s2">&quot;./bin/rocketz.js&quot;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure></div> </section> <!-- 辅助性工具 --> <section> <p>完全自己去写命令和 flag 的处理逻辑是件让人蛋碎的事情</p> <p class="fragment">还好已经有一些第三方包可以起到辅助作用</p> <p class="fragment">我主要用到了三个包</p> <ul class="fragment"> <li> <a href="https://www.npmjs.com/package/meow" target="_blank" rel="external nofollow">meow</a> </li> <li class="fragment"><a href="https://www.npmjs.com/package/liftoff" target="_blank" rel="external nofollow">lift</a></li> <li class="fragment"><a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="external nofollow">inquirer</a></li> </ul> <p class="fragment">偷懒万岁！*\(^o^)/*</p> </section> <!-- meow 简介 --> <section data-background-image="/assets/slides/develop-with-node/meow-a34fdb867ea59aa410a42ee11422a36488faf2659980f09c1c91e9a4723f3d8a.gif" style="text-shadow: 1px 1px #666;"> <p>meow 的主要作用有</p> <ol class="fragment"> <li>将命令和 flag 分别转化为数组和对象以便于读取</li> <li class="fragment">自动生成 <code>--version</code> 和 <code>--help</code> 这两个 flag</li> <li class="fragment">设置 flag 的别名</li> </ol> </section> <!-- meow 的用法 --> <section data-background-image="/assets/slides/develop-with-node/meow-a34fdb867ea59aa410a42ee11422a36488faf2659980f09c1c91e9a4723f3d8a.gif" style="text-shadow: 1px 1px #666;"> <p>meow 的用法很简单</p> <div class="fragment"><figure class="highlight"><pre><code class="language-js" data-lang="js"><span></span><span class="kd">const</span> <span class="nx">meow</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;meow&quot;</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">helper</span> <span class="o">=</span> <span class="nx">meow</span><span class="p">({},</span> <span class="p">{</span>
  <span class="nx">alias</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">h</span><span class="o">:</span> <span class="s2">&quot;help&quot;</span><span class="p">,</span>
    <span class="nx">v</span><span class="o">:</span> <span class="s2">&quot;version&quot;</span>
  <span class="p">}</span>
<span class="p">});</span></code></pre></figure></div> <div class="fragment"> <p>如果在命令行中输入</p> <figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span></span>rocketz init qiniu --config wantu</code></pre></figure> </div> <p class="fragment">程序中调用 <code>helper.input</code> 和 <code>helper.flags</code></p> <div class="fragment"><figure class="highlight"><pre><code class="language-js" data-lang="js"><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">helper</span><span class="p">.</span><span class="nx">input</span><span class="p">);</span>    <span class="c1">// 输出 [&quot;init&quot;, &quot;qiniu&quot;]</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">helper</span><span class="p">.</span><span class="nx">flags</span><span class="p">);</span>    <span class="c1">// 输出 {config: &quot;wantu&quot;}</span></code></pre></figure></div> </section> <!-- liftoff 简介 --> <section> <p>liftoff 主要解决了几件事情</p> <ol class="fragment"> <li>定义、查找并读取配置文件</li> <li class="fragment">作为命令处理的入口</li> </ol> </section> <!-- liftoff 的用法 --> <section> <p>liftoff 的用法也较为简单</p> <div class="fragment"><figure class="highlight"><pre><code class="language-js" data-lang="js"><span></span><span class="kd">const</span> <span class="nx">Liftoff</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;liftoff&quot;</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">APP_NAME</span> <span class="o">=</span> <span class="s2">&quot;rocketz&quot;</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="ow">new</span> <span class="nx">Liftoff</span><span class="p">({</span>
  <span class="nx">name</span><span class="o">:</span> <span class="nx">APP_NAME</span><span class="p">,</span>
  <span class="nx">configName</span><span class="o">:</span> <span class="sb">`.</span><span class="si">${</span><span class="nx">APP_NAME</span><span class="si">}</span><span class="sb">`</span><span class="p">,</span>
  <span class="nx">extensions</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">&quot;rc&quot;</span><span class="o">:</span> <span class="kc">null</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="c1">// 启动应用</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">launch</span><span class="p">({</span>
    <span class="nx">cwd</span><span class="o">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">cwd</span><span class="p">(),</span>
    <span class="nx">configPath</span><span class="o">:</span> <span class="nx">__dirname</span>
  <span class="p">},</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">env</span> <span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 命令和 flag 的处理逻辑</span>
<span class="p">});</span></code></pre></figure></div> </section> <!-- inquirer --> <section> <p>inquirer 可以让你设置一些「问答题」</p> <p class="fragment">通过在命令行中的一步步操作</p> <p class="fragment">完成对配置文件内容的设置</p> </section> <section> <p>meow<span class="fragment">＋liftoff</span><span class="fragment">＋inquirer</span><span class="fragment">＝一个完整的命令行工具</span></p> </section> </section> <!-- 服务端开发 --> <section> <section> <h2>服务端开发</h2> <p>这是另一种较高级的 node 应用</p> <p class="fragment">也是给前端带来新希望的一种应用</p> </section> <section> <p>做服务端开发离不开 web 框架</p> <p class="fragment">在我眼里总共有两种类型</p> <ol class="fragment"> <li>全栈式</li> <li class="fragment">REST</li> </ol> </section> <section> <p>所谓的「全栈式」框架</p> <p class="fragment">就是完整地提供了 MVC 支持的框架</p> </section> <section> <p>轻量点的有 <a href="https://www.npmjs.com/package/express" class="fragment" target="_blank" rel="external nofollow">Express</a><span class="fragment">、<a href="https://www.npmjs.com/package/koa" target="_blank" rel="external nofollow">Koa</a></span></p> <p class="fragment">它们都太轻量</p> <p class="fragment">以至于需要自己去东拼西凑成一套完整的框架</p> <p class="fragment">不太适合快速开发</p> </section> <section> <p>有个叫做 <a href="https://www.npmjs.com/package/sails" target="_blank" rel="external nofollow">Sails</a> 的框架</p> <p class="fragment">看名字也许会想到了什么</p> <p class="fragment">没错，就是那辆小火车</p> <p class="fragment">这是一个借鉴 Ruby on Rails 的大而全的框架</p> <p class="fragment">挺适合快速开发的</p> </section> <section> <p>然而，在现在这种多终端的使用环境下</p> <p class="fragment">全栈式的框架显得不那么灵活</p> <p class="fragment">服务端只需要通过 API 接口提供数据就好了</p> <p class="fragment"><a href="https://www.npmjs.com/package/restify" target="_blank" rel="external nofollow">restify</a> 就是为此而生</p> </section> </section> <section> <p>Node.js 改变了我</p> <p class="fragment">让我从纯前端渐渐转变为可以贯穿 web 栈的<span class="fragment">伪·</span>全栈</p> </section> <section> <p>我的废话说完了</p> <p class="fragment grow">谢谢！</p> </section> </div> </main> <script type="text/javascript" src="/assets/pages/slide-b3d161e4a2768aae8b8377689682b63c019c37547176b3331f0dc37096134ffd.js"></script> </body> </html>
